'''
Same as part 4, just replace clf.classify() with yolov5_func.classify() and you don't need to transfer each parking space images to grayscale images (just resize to 36 x 16)
Save a txt file (Yolov5_pred.txt) of temporal parking slots occupation
(Total execution time is about 30 mins)

The explanation of yolov5_func.classify():
Parameters:
    parking_space_image: parking space image of the frame (you need to resize to 36 x 16)
    weight_path: The path of the trained model. (e.g., '/content/gdrive/MyDrive/Colab Notebooks/best.pt')
    confidence_threshold: Only show predictions whose probability exceeds confidence_threshold.
    image_size: e.g., (36, 16)
Returns:
    1 if your model determines that this image has a car
    0 otherwise
Usage:
    prediction = yolov5_func.classify(parking_space_image, weight_path, confidence_threshold, image_size)
'''

import HW1_material.yolov5_func as yolov5_func
import cv2
import matplotlib.pyplot as plt
import numpy as np

def crop(x1, y1, x2, y2, x3, y3, x4, y4, img) :
    """
    This function ouput the specified area (360 x 160 parking space image) of the input frame according to the input of four xy coordinates

      Parameters:
        (x1, y1, x2, y2, x3, y3, x4, y4, frame)
        
        (x1, y1) is the lower left corner of the specified area
        (x2, y2) is the lower right corner of the specified area
        (x3, y3) is the upper left corner of the specified area
        (x4, y4) is the upper right corner of the specified area
        frame is the frame you want to get it's parking space image
        
      Returns:
        parking_space_image (image size = 360 x 160)
      usage:
        parking_space_image = utils.crop(x1, y1, x2, y2, x3, y3, x4, y4, img)
    """
    left_front = (x1, y1)
    right_front = (x2, y2)
    left_bottom = (x3, y3)
    right_bottom = (x4, y4)
    src_pts = np.array([left_front, right_front, left_bottom, right_bottom]).astype(np.float32)
    dst_pts = np.array([[0, 0], [0, 160], [360, 0], [360, 160]]).astype(np.float32)
    projective_matrix = cv2.getPerspectiveTransform(src_pts, dst_pts)
    croped = cv2.warpPerspective(img, projective_matrix, (360,160))
    return croped

weight_path = os.path.join(yourPath, 'best.pt')
img_save_path = os.path.join(yourPath, 'Yolov5_first_frame.png')
txt_save_path = os.path.join(yourPath, 'Yolov5_pred.txt')
confidence_threshold = 0.4 # you can adjust by yourself
# Begin your code (Part 5)

import cv2

gif_path = "/content/yolov5/HW1_material/detect/video.gif"
bounder_path = "/content/yolov5/HW1_material/detect/detectData.txt"

with open(bounder_path) as f:
  lines = f.readlines()

cap = cv2.VideoCapture(gif_path)
now_at = 0
final_result = []

while(cap.isOpened()):
  ret, frame = cap.read()

  tmp_classify_result = []

  if ret == True:

    now_at += 1
    print("we are now at frame no.", now_at)
    
    for i in range(int(lines[0])):
      tmp_object = list(map(int, lines[i+1].split(" ")))
      tmp = np.fromiter(tmp_object, dtype=np.int)

      cropped_frame = crop(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], frame)
      # cropped_frame = np.rot90(cropped_frame)
      cropped_frame = cv2.resize(cropped_frame, (36, 16))
      cropped_frame = cv2.cvtColor(cropped_frame, cv2.COLOR_BGR2GRAY)

      classify_result = yolov5_func.classify(cropped_frame, weight_path, confidence_threshold, (36, 16))
      #prediction = yolov5_func.classify(parking_space_image, weight_path, confidence_threshold, image_size)

      if classify_result == 1:
        tmp_classify_result.append(1)

        if now_at == 1:
          draw = np.array([[tmp[4], tmp[5]], [tmp[6], tmp[7]], [tmp[2], tmp[3]], [tmp[0], tmp[1]]])
          cv2.polylines(frame, [draw], True, (0,255,0), 2)
      else:
        tmp_classify_result.append(0)

    final_result.append(tmp_classify_result)
    if now_at == 1:
      frame = frame[:, :, [2,1,0]]
      plt.imshow(frame)
      plt.show()

  else:
    file = open("Adaboost_pred.txt", "w+")
    for frame_result in final_result:
      for i in range(len(frame_result)):
        file.write(str(frame_result[i]))
        if i != (len(frame_result)-1):
          file.write(" ")
      file.write("\n")
    file.close()
    break

cap.release()

# End your code (Part 5)